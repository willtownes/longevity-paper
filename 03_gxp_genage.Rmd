---
title: "Predicting Pro vs Anti Longevity from Gene Expression"
author: "Will Townes"
date: "3/29/2018"
output: html_document
---

Using gene expression alone to predict pro vs anti longevity genes from genage database.

```{r}
library(SingleCellExperiment) #also loads SummarizedExperiment
#library(dplyr)
library(class)
library(glmnet)
library(caret)
library(ROCR)
source("util.R") #this loads dplyr too
spp<-c("yeast","worm")
sp<-spp[2]
if(sp=="yeast"){
  mutants<-"responsive"
  measured_genes<-TRUE
}
```

## Data Loading

Merge Gene Expression and Survival Data
Find genes that were measured in the deleteome across perturbations and also for which we have perturbation-survival data.

```{r}
sv<-load_genage(sp)

if(sp=="yeast"){
  if(mutants=="all"){
    ge<-readRDS("data/deleteome_all_mutants_controls.rds")
  } else if(mutants=="responsive"){
    ge<-readRDS("data/deleteome_responsive_mutants.rds")
  } else { stop("invalid mutant") }
  if(measured_genes==TRUE){
    #expressed genes vs RLS perturbs
    table(rownames(ge) %in% sv$symbol)
    table(sv$symbol %in% rownames(ge))
    sv<-sv %>% subset(symbol %in% rownames(ge))
    ge<-ge[rownames(ge) %in% sv$symbol,]
    X<-assay(ge,"logratio")[sv$symbol,] #sort order match
  } else {
    #perturbed genes vs RLS perturbs
    ge_perts<-colData(ge)$pert_geneSymbol
    table(ge_perts %in% sv$symbol)
    table(sv$symbol %in% ge_perts)
    sv<-sv %>% subset(symbol %in% ge_perts)
    ge<-ge[,ge_perts %in% sv$symbol]
    rownames(ge)<-paste0("expr_",rownames(ge))
    colnames(ge)<-colData(ge)$pert_geneSymbol
    X<-t(assay(ge,"logratio")[,sv$symbol])
  }
} else if(sp=="worm") {
  #sce<-readRDS("./data/worm_scrna_atlas.rds")
  #X<-assay(sce,"logcounts")
  X<-read.table("./data/worm_scrna_atlas_merged_rel_abund.txt")
  rownames(sv)<-sv$symbol
  gg<-intersect(rownames(sv),rownames(X))
  X<-as.matrix(X[gg,])
  X<-X[,apply(X,2,sd)>0] #remove cells with no variation
  #remove cells with fewer than 10 nonzero genes
  X<-X[,colSums(X>0)>=10]
  dim(X)
  sv<-sv[gg,]
}
y<-sv$pro_longevity
names(y)<-rownames(X)

# train/test split
train_idx<-createDataPartition(y,p=.75,list=FALSE)
ytrn<-y[train_idx]
ytst<-y[-train_idx]
```

dimensionality reduction

```{r}
pca<-TRUE
if(pca){
  Xs<-X %*% svd(X,nv=1000)$v #if PCA adjustment
  colnames(Xs)<-paste0("pca_",seq.int(5000))
} else {
  #random subset of columns or use PCA to reduce dims
  nsample<-min(1000,ncol(X))
  Xs<-X[,sample.int(ncol(X),nsample)]
}
Xtrn<-Xs[train_idx,]
Xtst<-Xs[-train_idx,]
```

knn classifier

```{r}
Xtrn<-X[train_idx,]
Xtst<-X[-train_idx,]
fit<-knn(Xtrn,Xtst,ytrn,k=10,prob=TRUE)
probs<-attr(fit,"prob")
probs[fit==0]<-1-probs[fit==0]
preds<-prediction(probs,ytst)
auc.tmp<-performance(preds,"auc")
(auc<-as.numeric(auc.tmp@y.values)) #0.6
```

gradient boosted machines

```{r}
system.time(res2<-train(Xtrn,factor(ytrn), method="gbm", distribution="bernoulli", preProcess=NULL, verbose=FALSE, metric="Kappa", trControl=trainControl("cv",5), tuneGrid=expand.grid(interaction.depth=c(1,2),n.trees=c(800,1600),shrinkage=.005,n.minobsinnode=10)))
print(res2)
probs<-predict(res2,newdata=Xtst,type="prob")[,"1"]
preds<-prediction(probs,ytst)
auc.tmp<-performance(preds,"auc")
(auc<-as.numeric(auc.tmp@y.values)) #0.6
```

svm with caret
```{r}
system.time(res3<-train(Xtrn,factor(ytrn), method="svmRadial", distribution="bernoulli", preProcess=NULL, verbose=FALSE, metric="Kappa", trControl=trainControl("cv",5),prob.model=TRUE))
print(res3)
probs<-predict(res3,newdata=Xtst,type="prob")[,"1"]
preds<-prediction(probs,ytst)
auc.tmp<-performance(preds,"auc")
(auc<-as.numeric(auc.tmp@y.values)) #0.6
```

GLMnet prediction

```{r}
pp<-preProcess(Xtrn,method=c("center","scale"))
Xtrn<-cbind(1,predict(pp,Xtrn))
Xtst<-cbind(1,predict(pp,Xtst))

#folds<-createFolds(ytrn)
#res<-train(mean_lifespan~.,data=d[train_idx,],preProcess=c("center","scale"))

alpha<-if(pca){ 0.0 }else{ .9 }
res<-cv.glmnet(Xtrn,ytrn,family="binomial",alpha=alpha)
probs<-predict(res, newx=Xtst, s="lambda.min", type="response")
#saveRDS(res,file="glmnet_fit.rds")
plot(res)
preds<-prediction(probs,ytst)
auc.tmp<-performance(preds,"auc")
(auc<-as.numeric(auc.tmp@y.values)) #0.5
```

```{r}
rmse<-function(ytrue,ypred){
  sqrt(mean((ytrue-ypred)^2))
}
(rmse_glmnet<-rmse(probs,ytst))
(rmse_mean_only<-rmse(mean(ytrn),ytst))
```

